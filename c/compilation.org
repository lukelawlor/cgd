<2023-12-24 Sun> Note: so far this file only details what was covered in meetings. I will add much more content to it later.

* The C compilation process
If you are writing your program entirely in one file, compiling your program with this shell command will do:

#+begin_src sh
	cc file.c -o executable_name
#+end_src

If you split your code across /multiple/ *source files* (.c files) and *header files* (.h files), however, you may want to understand the compilation process at a deeper level. That is what this document will detail.

** Translation units and object files
A *translation unit* or *compilation unit* is a collection of source code that the compiler reads to output an object file. A translation unit is made up of a source file and all of the header files it may include.

An *object file* (.o file) contains the machine code of a translation unit. One or more object files are fed to the *linker*, a program which will link data, such as function calls between object files, to output the final executable of a program.

** Producing direct object files
When you run this command:

#+begin_src sh
	cc file.c -o executable_name
#+end_src

The compiler will produce object files and link them automatically for you. To only produce object files and skip linking, use the =-c= flag:

#+begin_src sh
	cc -c file.c
#+end_src

This will produce the object file =file.o=. If you want to explicitly choose the object file name, use the =-o= flag:

#+begin_src sh
	cc -c file.c -o file.o
#+end_src

** Linking object files to produce an executable
To produce an executable using all of your object files, run this command:

#+begin_src sh
	cc file.o -o program
#+end_src

This command will produce the executable file =program=. You may insert as many object file names before =-o= as you like.

* Linkage
*Linkage* is a property of variables and functions that determines if they can be accessed in different source files that are to be compiled and linked into one program.

There are two types of linkage: internal and external.

Variables and functions with *internal linkage* can only be accessed in the translation unit they are defined in. See [[static][here]] to learn how to declare variables and functions with this linkage.

Variables and functions with *external linkage* can be accessed in every translation unit.

** Using functions across different source files
*** Demonstrational code
To use /any/ function or variable across different source files (which will be included in different translation units), the function or variable needs to have external linkage.

By default, all functions have external linkage.

Here is some code to illustrate this:

<<external_linkage_demo>>

This is my file =sum.c=, which contains the definition for the function =sum=:

#+begin_src C
	// Returns the sum of two integers
	int sum(int x, int y)
	{
		return x + y;
	}
#+end_src

This is my file =main.c=:

#+begin_src C
	#include <stdio.h>

	// Returns the sum of two integers
	int sum(int x, int y);

	int main(void)
	{
		printf("The sum of 2 and 3 is %d\n", sum(2, 3));
		return 0;
	}
#+end_src

I will use both of these source files in the same program, which I will compile with the following shell commands:

#+begin_src sh
	gcc -c sum.c
	gcc -c main.c
	gcc sum.o main.o -o program
#+end_src

This should work perfectly fine. Functions have external linkage by default, therefore =sum= has external linkage so I am able to call it from =main.c= even if it is defined in =sum.c=. The program links successfully with the execution of the last command because the linker was able to find the definition of =sum= in =sum.o=.

If I left =sum.o= out of the final compile command, I would see a linker error such as this:

#+begin_src text
/usr/lib/gcc/x86_64-pc-linux-gnu/13/../../../../x86_64-pc-linux-gnu/bin/ld: main.o: in function `main':
main.c:(.text+0xf): undefined reference to `sum'
collect2: error: ld returned 1 exit status
#+end_src

It is the *linker*'s job to handle linkage of variables and functions, not the compiler's job. That is why we get a linker error. You can typically tell a linker error apart from a compiler error because linker errors contain some reference to the program =ld=, which is the linker on UNIX.

*** The problem with our code and the solution
While our example code /does/ work, it has some flaws that become apparent when we begin adding more to our program.

What if we wanted to include more source files that used the =sum= function? We would need to copy and paste the function prototype of =sum= in each of these files. That would be a violation of the DRY principle: don't repeat yourself. Violating DRY means your program will be harder to modify. If we wanted to change the arguments of =sum=, we would need to find every occurence of =sum='s prototypes and change them as well!

The solution is to store the function prototype for =sum= in a [[header_files][header file]], which we will cover in the next section.

** TODO Header files
<<header_files>>

*Header files* (ending in .h), or *headers*, are files that contain commonly re-used code to be =#include='d at the top of other header or source files in our program, hence the name.

As we learn more about different C concepts, we will need to know whether the lines of code they involve should go in header or source files. Generally, code statements (instructions that cause the computer to actually execute something) go in source files, and information for the compiler to use, such as function prototypes, goes in header files.

*** TODO Using function prototypes in header files
Function prototypes for functions with external linkage are best placed in header files.

**** Demonstrational code
Building on our [[external_linkage_demo][previous code for demonstrating use of functions with external linkage]], I will create a new header file =sum.h=:

#+begin_src C
	// Returns the sum of two integers
	int sum(int x, int y);
#+end_src

Now, instead of writing the raw function prototype into =main.c=, I can simply =#include= =sum.h= in =main.c=:

#+begin_src C
	#include <stdio.h>

	#include "sum.h" // For sum()

	int main(void)
	{
		printf("The sum of 2 and 3 is %d\n", sum(2, 3));
		return 0;
	}
#+end_src

**** #include paths
Notice how I used double quotes around =sum.h= in the =#include= statement. These indicate that =sum.h= is a relative path. Any path enclosed in double quotes indicates a path relative to the directory that the file containing the =#include= statement is in.

Any path enclosed in angle brackets =<>=, such as =stdio.h=, is relative to the include directories available to the compiler. The compiler will search for the named file and error if it isn't found in any of the include directories.

On UNIX, =/usr/include= is one of these directories. You can add to this list of directories by running the compiler with the =-I= option. For example, passing =-I.= will add the working directory to the list of include directories.

See [[../unix/shell.org][this document]] for an explanation of relative vs absolute paths.

**** #include comments
I added the comment "For sum()" after =#include='ing =sum.h= to make my intentions clearer. I recommend that you do the same in commenting what you need from each header file.

The more code we add to =sum.h=, the harder it is to tell which functions need to be used by which source files. Also, if we want to move a function prototype from =sum.h= to some other header file, our comments will let us know which files need their =#include= statements altered accordingly.

**** TODO The benefits of header files
Header files allow us to follow the DRY (don't repeat yourself) principle. With them, we can avoid rewriting the same function prototypes where they are needed. We can also update our function prototypes everywhere they are used by just changing them in one file.

*** TODO Header guards
A *header guard* is a mechanism that prevents a header file from being included more than once in one translation unit. Avoiding the use of one can cause errors.

So far, we only know to add function prototypes to our header files. No errors occur if these are repeated, however, code that we will later learn to place in header files /can/ cause errors when repeated.

**** Traditional #ifndef ... #endif guards
The standard way to implement header guards is to use the =#ifndef=, =#define= and =#endif= preprocessor statements like so:

=sum.h=:

#+begin_src C
	#ifndef SUM_H
	#define SUM_H

	// Returns the sum of two integers
	int sum(int x, int y);

	#endif
#+end_src

The =#ifndef= statement is short for "if not defined." It checks

**** TODO #pragma once
** TODO Using global variables across different source files

** TODO Using structs across different source files

** TODO The static keyword in linkage
<<static>>

* Sources
+ For Linkage
  + [[https://www.geeksforgeeks.org/internal-linkage-external-linkage-c/][geeksforgeeks.org]]
  + [[https://learn.microsoft.com/en-us/cpp/c-language/linkage?view=msvc-170][microsoft.com]]
